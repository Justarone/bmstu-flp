\chapter{Задания}

\section{Написать функцию, которая переводи температуру в системе Фаренгейта в температуру в системе по Цельсию \texttt{(defun f-to-c (temp) ... )}}

\begin{lstlisting}
(defun f-to-c (temp) 
  (* (/ 5 9) (- temp 32.0)))
\end{lstlisting}

\section{Что получится при вычислении каждого из выражений}

\begin{lstlisting}
(list 'cons T Nil)
\end{lstlisting}
Результат: \texttt{(cons T Nil)}

\begin{lstlisting}
(eval (eval (list 'cons T Nil)))
\end{lstlisting}
Результат: ошибка: после применения внутреннего \texttt{eval} вычисленное значение будет \texttt{(T)}. Затем попытка применить \texttt{eval} к полученному заканчивается ошибкой.

\begin{lstlisting}
(apply #'cons '(T Nil))
\end{lstlisting}
Результат: \texttt{(T)}

\begin{lstlisting}
(eval (list 'cons T Nil))
\end{lstlisting}
Результат: \texttt{(T)}

\begin{lstlisting}
(list 'eval Nil)
\end{lstlisting}
Результат: \texttt{(eval Nil)}

\begin{lstlisting}
(eval Nil)
\end{lstlisting}
Результат: \texttt{Nil}

\begin{lstlisting}
(eval (list 'eval Nil))
\end{lstlisting}
Результат: \texttt{Nil}

\clearpage

\section{Написать функцию, вычисляющую катет по заданной гипотенузе и другому катету прямоугольного треугольника, и составить диаграмму ее вычисления.}

\begin{lstlisting}
(defun leg (h l)
  (sqrt (- (* h h) (* l l))))
\end{lstlisting}

\vspace{60mm}

\section{Написать функцию, вычисляющую площадь трапеции по ее основаниям и высоте, и составить диаграмму ее вычисления.}

\begin{lstlisting}
(defun area (a b h) 
  (* (/ (+ a b) 2) h))
\end{lstlisting}

\chapter{Ответы на вопросы к лабораторной работе}

\section{Синтаксическая форма и хранение программы в памяти}

В LISP формы представления программы и обрабатываемых ею данных одинаковы и представляются в виде S-выражений. Поэтому программы могут обрабатывать и преобразовывать другие программы и даже самих себя. В процессе трансляции можно введенное и сформированное в результате вычислений выражение данных проинтерпретировать в качестве программы и непосредственно выполнить. Так как программа представляет собой S-выражение, в памяти она представлена либо как атом (5 указателей; форма представления атома в памяти), либо списковой ячейкой (бинарный узел; 2 указателя).

\section{Трактовка элементов списка}

Первый аргумент списка, который поступает на вход интерпретатору, трактуется как имя функции, остальные --- как аргументы этой функции.

\section{Порядок реализации программы}

Программа в языке LISP представляется S-выражением, которое передается интерпретатору --- функции \texttt{eval}, которая выводит последний, полученный после обработки S-выражения, результат.
Работа функции \texttt{eval} представлена на картинке ниже.

\imgw{170mm}{eval}{Схема работы функции \texttt{eval}}

\section{Способы определения функций}

\subsection{Через \texttt{defun}}

Синтаксис:
\begin{lstlisting}
(defun function-name (list-of-arguments) function-body)
\end{lstlisting}

Пример определения:
\begin{lstlisting}
(defun sqr(x) (* x x))
\end{lstlisting}

Пример вызова:
\begin{lstlisting}
(sqr 2)
\end{lstlisting}
Результат: 4

\subsection{Через \texttt{lambda}}

Синтаксис:
\begin{lstlisting}
(lambda (list-of-arguments) function-body)
\end{lstlisting}

Пример использования:
\begin{lstlisting}
((lambda (x) (* x x)) 2)
\end{lstlisting}
Результат: 4
