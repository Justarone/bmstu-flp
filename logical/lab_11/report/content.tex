\chapter{Лабораторная работа №11}

\textbf{Задание:} запустить среду \texttt{Visual Prolog 5.2}.  Настроить утилиту \texttt{TestGoal}. Запустить тестовую программу, проанализировать реакцию системы и множество ответов. Разработать свою программу – <<Телефонный справочник>>. Протестировать работы программы.

\begin{lstlisting}
domains
  name = string
  phone = integer
  surname = string
  
predicates
  entry(phone, name, surname)

clauses
  entry(666, "Dima", "Yacubovich").
  entry(777, "Lexa", "Romanovich").
  entry(888, "Lexa", "Petrovich").
  entry(1, "Mixail", "Nintendovich").
  entry(800, "Sergey", "Kononenkovich").
  
goal
  entry(Phone, "Lexa", Surname).
\end{lstlisting}

Программа на языке \texttt{Prolog} представляет собой базу знаний и вопрос. База знаний --- набор фактов и правил, которые формируют базу знаний о предметной области. Факт --- частный случай правила, состоит только из заголовка и с его помощью фиксируется \textit{истиностное} отношение между объектами предметной области. С помощью правила также фиксируются знания, однако правила обладают телом, в котором фиксируется условие истинности правила. При поиске ответа на вопрос \texttt{Prolog} рассматривает альтернативные варианты и находит все возможные решения --- множества значений переменных, при которых на поставленный вопрос можно ответить \texttt{''да''}.

Программа состоит из разделов (структура программы), каждый имеет свой заголовок:
\begin{itemize}
    \item \texttt{constants} --- раздел описания констант.
    \item \texttt{domains} --- раздел описания доменов.
    \item \texttt{database} --- раздел описания предикатов внутренней базы данных.
    \item \texttt{predicates} --- раздел описания предикатов.
    \item \texttt{clauses} --- раздел описания предложений базы знаний.
    \item \texttt{goal} --- раздел описания внутренней цели (вопроса).
\end{itemize}

В программе не обязательно должны быть описаны все разделы.

\chapter{Лабораторная работа №12}


\textbf{Задание:} составить программу --- базу знаний, с помощью которой можно определить, например, множество студентов, обучающихся в одном ВУЗе. Студент может одновременно обучаться в нескольких ВУЗах. Привести примеры возможных вариантов вопросов и варианты ответов (не менее 3-х). Описать порядок формирования вариантов ответа.
\begin{itemize}
    \item Исходную базу знаний сформировать с помощью только фактов.
    \item *Исходную базу знаний сформировать, используя правила.
    \item *Разработать свою базу знаний (содержание произвольно).
\end{itemize}


\begin{lstlisting}
domains
  name, surname, university = string
 
predicates
  student(name, surname, university)
  
clauses
  student("Alexey", "Romanov", "BMSTU").
  student("Alexey", "Romanov", "MSU").
  student("Mikhail", "Nitenko", "BMSTU").
  student("Sergey", "Kononenko", "BMSTU").
  student("Dmitry", "Yacuba", "MSU").
  student("Pavel", "Perestoronin", "BMSTU").
  student("Anton", "Olenev", University) :- student("Alexey", "Romanov", University), student("Mikhail", "Nitenko", University).
  
goal
  student(Name, Surname, "MSU").
  /*
  Name=Alexey, Surname=Romanov
  Name=Dmitry, Surname=Yacuba
  */
  %student("Alexey", "Romanov", University). 
  /*
  University=BMSTU
  University=MSU
  */
  %student(Name, Surname, "ITMO").
  /*
  No solution
  */
\end{lstlisting}

Порядок формирования результатов:

\begin{enumerate}
    \item \texttt{student(Name, Surname, "MSU").}
        При сравнении вопроса с 2 предложениями базы знаний унификация вопроса и предложения базы знаний проходит успешно: совпадает функтор, арность, успешно унифицируются все аргументы (а переменные \texttt{Name} и \texttt{Surname} конкретизируются значениями аргументов функтора предложения БЗ, стоящими на тех же позициях соответственно, и возвращаются в качестве решений)
    \item \texttt{student(''Alexey'', ''Romanov'', University).}
        Аналогичная ситуация, только переменная \texttt{University} в этой ситуации конкретизируется значениями \textit{BMSTU} и \textit{MSU}
    \item \texttt{student(Name, Surname, "ITMO").}
        Унификация вопроса не проходит ни с одним предложением базы знаний (не проходит унификация третьего аргумента, потому что для 2 констант унификация успешно проходит только при их совпадении, а в базе знаний нет функтора \texttt{student} с 3 аргументом \texttt{''ITMO''})
\end{enumerate}

\chapter{Лабораторная работа №13}

\textbf{Задание:} составить программу, то есть модель предметной области – базу знаний, объединив в ней информацию – знания:

\begin{itemize}
    \item <<Телефонный справочник>>: Фамилия, №тел, Адрес – структура (Город, Улица, №дома, №кв)
    \item <<Автомобили>>: Фамилия\_владельца, Марка, Цвет, Стоимость и др.
    \item <<Вкладчики банков>>: Фамилия, Банк, счет, сумма, др.
\end{itemize}


Владелец может иметь несколько телефонов, автомобилей, вкладов (Факты).
Используя правила, обеспечить возможность поиска:


\begin{enumerate}
    \item A. По № телефона найти: Фамилию, Марку автомобиля, Стоимость автомобиля (может быть несколько)

        B. Используя сформированное в предыдущем пункте правило, по №телефона найти только Марку автомобиля (автомобилей может быть несколько)

    \item Используя простой, не составной вопрос: по Фамилии (уникальна в городе, но в разных городах есть однофамильцы) и Городу проживания найти: Улицу, проживания, Банки, в которых есть вклады и №телефона.
\end{enumerate}

Для задания 1 и 2 для одного из вариантов ответов, и для A. и для B., описать словесно порядок поиска ответа на вопрос, указав, как выбираются знания, и, при этом, для каждого этапа унификации, выписать подстановку – наибольший общий унификатор, и соответствующие примеры термов.

\begin{lstlisting}
domains
  surname = string
  city, street = string
  house, flat = integer
  phone = string
  address = addr(city, street, house, flat)
  mark = string
  color = string
  price = integer
  bank = string
  id, amount = integer
  
predicates
  phone(surname, phone, address)
  car(surname, mark, color, price)
  bank_depositor(surname, bank, id, amount)
  car_by_phone(phone, surname, mark, price)
  only_mark_by_phone(phone, mark)
  data_by_surname_and_city(surname, city, street, bank, phone)
  
clauses
  phone("Perestoronin", "+79999999999", addr("Moscow", "Lesnaya", 12, 2)).
  phone("Romanov", "+71111111111", addr("Moscow", "Lesnaya", 13, 87)).
  phone("Nitenko", "+73333333333", addr("Ekaterinburg", "Kamennaya", 13, 87)).
  phone("Yacuba", "+66666666666", addr("Moscow", "Wall-street", 123, 87)).
  car("Nitenko", "bmw", "green", 1000).
  car("Yacuba", "volkswagen", "red", 10000).
  car("Yacuba", "golfR", "black", 20000).
  car("Romanov", "bike", "white", 10).
  car("Perestoronin", "mercedes", "yellow", 30000).
  bank_depositor("Nitenko", "Sber", 22, 1000).
  bank_depositor("Yacuba", "Sber", 33, 10000).
  bank_depositor("Yacuba", "Alfa", 44, 20000).
  bank_depositor("Romanov", "Sper", 238, 10).
  bank_depositor("Perestoronin", "Maze", 1, 10000).
  
  car_by_phone(Phone, Surname, Mark, Price) :- phone(Surname, Phone, _), car(Surname, Mark, _, Price).
  only_mark_by_phone(Phone, Mark) :- car_by_phone(Phone, _, Mark, _).
  data_by_surname_and_city(Surname, City, Street, Bank, Phone) :- phone(Surname, Phone, addr(City, Street, _, _)), bank_depositor(Surname, Bank, _, _).
  
goal
  %car_by_phone("+66666666666", Surname, Mark, Price).
  %only_mark_by_phone("+66666666666", Mark).
  data_by_surname_and_city("Yacuba", "Moscow", Street, Bank, Phone).
\end{lstlisting}


\section{Поиски ответов на вопрос}

Выполнены на отдельных листах и приложены к отчету.

\section{Теоретические вопросы}

\subsection{Что такое терм?}

Терм - основной элемент языка \texttt{Prolog}. Терм – это:
\begin{enumerate}
	\item Константа: 
	\begin{itemize}
		\item Число (целое, вещественное),
		\item Символьный атом (комбинация символов латинского алфавита, цифр и символа подчеркивания, начинающаяся со строчной буквы),
		\item Строка: последовательность символов, заключенных в кавычки.
	\end{itemize}
	\item Переменная:
	\begin{itemize}
		\item Именованная – обозначается комбинацией символов латинского алфавита, цифр и символа подчеркивания, начинающейся с прописной буквы или символа подчеркивания,
		\item Анонимная  - обозначается символом подчеркивания
	\end{itemize}
	\item Составной терм:
	Это средство организации группы отдельных элементов знаний в единый  объект,  синтаксически представляется: f(t1, t2, …,tm), где f -  функтор (отношение между объектами), t1, t2, …,tm – термы, в том  числе  и составные.
\end{enumerate}

\subsection{Что такое предикат в матлогике (математике)?}

Предикат (\textit{n}-местный, или \textit{n}-арный) --- это функция с множеством значений \texttt{\{0, 1\}} (или \texttt{\{ложь, истина\}}), определённая на множестве $M^n = (M_1, M_2, \ldots, M_n)$. Таким образом, каждый набор элементов множества характеризуется либо как <<истинный>>, либо как <<ложный>>.

\subsection{Что описывает предикат в \texttt{Prolog}?}

Предикат в \texttt{Prolog} описывает отношение между аргументами процедуры. Процедурой в \texttt{Prolog} является совокупность всех правил, описывающих определенное отношение.

\subsection{Назовите виды предложений в программе и приведите примеры таких предложений из Вашей программы. Какие предложения являются основными, а какие – не основными?  Каковы: синтаксис и семантика (формальный смысл) этих предложений (основных и неосновных)?}

В \texttt{Prolog} есть два типа предложений: правила и факты. Правило имеет вид: \texttt{A :- B1, \ldots, Bn.} 
\texttt{A} называется заголовком правила, а \texttt{B1, \ldots, Bn} – телом правила. Заголовок содержит некоторое знание, а тело --- условие истинности этого знания. Факт является частным случаем правила --- в нем отсутствует тело.

Пример факта из программы: \texttt{car(''Yacuba'', ''volkswagen'', ''red'', 10000).}
  

Пример правила из программы: \texttt{car\_by\_phone(Phone, Surname, Mark, Price) :- phone(Surname, Phone, \_), car(Surname, Mark, \_, Price).}
  
Основными называются предложения, не содержащие переменных. Предложения, содержащие переменные называются неосновными. 

Синтаксис предложения: \texttt{заголовок (составной терм) :- тело (один или последовательность термов).} 

Предложения используются для формирования базы знаний о некоторой предметной области. Основное предложение описывает отношение конкретных объектов предметной области. Неосновное предложение описывает множество отношений, потому что переменная, входящая в предложение базы знаний, рассматривается только с квантором всеобщности.

\subsection{Каковы назначение, виды и особенности использования переменных в программе на \texttt{Prolog}? Какое предложение БЗ сформулировано в более общей – абстрактной форме: содержащее или не содержащее переменных?}

Переменные предназначены для обозначения некоторого неизвестного объекта предметной области. Переменные бывают именованными и анонимными. Именованные переменные уникальны в рамках предложения, а анонимная переменная – любая уникальна. В разных предложениях может использоваться одно имя переменной для обозначения разных объектов.

В ходе выполнения программы выполняется связывание переменных с различными объектами, этот процесс называется конкретизацией. Это относится только к именованным переменным. Анонимные переменные не могут быть связаны со значением.

В более общей форме сформулировано предложение, содержащее переменные, так как заранее неизвестно, каким объектом будет конкретизирована переменная.

\subsection{Что такое подстановка?}

Пусть дан терм: $А(X_1, X_2, \ldots , X_n)$.
Подстановка --- множество пар, вида: \\ $\{X _ i = t _ i\}$, где $X_i$ --- переменная, а $t_i$ --- терм.

\subsection{Что такое пример терма? Как и когда строится? Как Вы думаете, система строит и хранит примеры?}

Пусть $\Theta =  \{X_1 = t_1, X_2= t_2, \dots , X_n = t_n \}$   –   подстановка, $A$ - терм. Результат применения подстановки к терму обозначается $A\Theta$.

Примером терма $A$ называется терм $B$, если существует подстановка $\Theta$ такая, что $B = A\Theta$.

Примеры термов строятся в ходе логического вывода. Для построения примера терма его переменные конкретизируются.
